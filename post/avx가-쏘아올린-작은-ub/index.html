<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AVX가 쏘아올린 작은 UB | blog.sryu.dev</title>
<meta name=keywords content><meta name=description content='시작하기 전에&mldr; 사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 &lsquo;요즘&rsquo;은 2023년 3월 말을 의미해요.
사건의 발단 요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.
printf("%f", 5 / 2); 교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.'><meta name=author content="Sangwon Ryu"><link rel=canonical href=https://blog.sryu.dev/post/avx%EA%B0%80-%EC%8F%98%EC%95%84%EC%98%AC%EB%A6%B0-%EC%9E%91%EC%9D%80-ub/><link crossorigin=anonymous href=/assets/css/stylesheet.e2fe4c636bc0907280105739fc2c658969a62f732f814e405c00c406e5ea42d9.css integrity="sha256-4v5MY2vAkHKAEFc5/CxliWmmL3MvgU5AXADEBuXqQtk=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.sryu.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.sryu.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.sryu.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.sryu.dev/apple-touch-icon.png><link rel=mask-icon href=https://blog.sryu.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.sryu.dev/post/avx%EA%B0%80-%EC%8F%98%EC%95%84%EC%98%AC%EB%A6%B0-%EC%9E%91%EC%9D%80-ub/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.1/styles/vs2015.min.css integrity="sha512-w8aclkBlN3Ha08SMwFKXFJqhSUx2qlvTBFLLelF8sm4xQnlg64qmGB/A6pBIKy0W8Bo51yDMDtQiPLNRq1WMcQ==" crossorigin=anonymous referrerpolicy=no-referrer><script async src="https://www.googletagmanager.com/gtag/js?id=G-PLVQY7PNKW"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PLVQY7PNKW",{anonymize_ip:!1})}</script><meta property="og:title" content="AVX가 쏘아올린 작은 UB"><meta property="og:description" content='시작하기 전에&mldr; 사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 &lsquo;요즘&rsquo;은 2023년 3월 말을 의미해요.
사건의 발단 요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.
printf("%f", 5 / 2); 교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.'><meta property="og:type" content="article"><meta property="og:url" content="https://blog.sryu.dev/post/avx%EA%B0%80-%EC%8F%98%EC%95%84%EC%98%AC%EB%A6%B0-%EC%9E%91%EC%9D%80-ub/"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-28T19:54:02+09:00"><meta property="article:modified_time" content="2023-03-28T19:54:02+09:00"><meta property="og:site_name" content="blog.sryu.dev"><meta name=twitter:card content="summary"><meta name=twitter:title content="AVX가 쏘아올린 작은 UB"><meta name=twitter:description content='시작하기 전에&mldr; 사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 &lsquo;요즘&rsquo;은 2023년 3월 말을 의미해요.
사건의 발단 요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.
printf("%f", 5 / 2); 교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.sryu.dev/post/"},{"@type":"ListItem","position":2,"name":"\bAVX가 쏘아올린 작은 UB","item":"https://blog.sryu.dev/post/avx%EA%B0%80-%EC%8F%98%EC%95%84%EC%98%AC%EB%A6%B0-%EC%9E%91%EC%9D%80-ub/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"\bAVX가 쏘아올린 작은 UB","name":"\u0008AVX가 쏘아올린 작은 UB","description":"시작하기 전에\u0026hellip; 사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 \u0026lsquo;요즘\u0026rsquo;은 2023년 3월 말을 의미해요.\n사건의 발단 요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.\nprintf(\u0026#34;%f\u0026#34;, 5 / 2); 교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.","keywords":[],"articleBody":"시작하기 전에… 사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 ‘요즘’은 2023년 3월 말을 의미해요.\n사건의 발단 요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.\nprintf(\"%f\", 5 / 2); 교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.5가 아니라 정수형 2라고 하시면서 printf가 %f 형식 지정자때문에 두 번째 인자로 double형의 값이 오기를 기대했는데, 예기치 않은 int형의 값이 전달됐기 때문에 0.0이 출력된다고 하셨어요.\n어라, 제 컴퓨터에서는 0.0이 출력되는데…\n친구의 컴퓨터에서 실행했을 때는 이상한 쓰레기값이 출력되네요?\n원인 분석 어떠한 요인이 다른 출력 결과를 유발시키는지 확인하기 위해 제 환경과 친구 환경의 차이점을 비교해봤어요. 우분투 버전, glibc 버전 모두 동일했어요. 저는 x86-64 macOS를 사용하고 있었고, 친구는 x86-64 Windows 머신 위에 x86-64 Ubuntu 게스트를 설치해 사용하고 있었어요. macOS와 Ubuntu의 차이 때문인지 확인하기 위해 x86-64 macOS에서 Parallels로 x86-64 Ubuntu 게스트를 설치해 테스트했고, 마찬가지로 제 환경에서는 0.0이 출력됐어요. 혹시 가상머신의 특성을 타는건가 싶어 친구가 사용하는 VirtualBox를 설치해 위의 코드를 실행해봤고 예상했던대로 쓰레기값이 출력됐어요. 가상머신의 특성을 탄다는건 알게 됐는데, 정확히 각 가상머신의 어떤 요소가 다른 출력값을 야기했을까요?\n디스어셈블 우선 동일한 바이너리를 다른 가상머신에서 실행했을 때 출력값이 달라지기 때문에 C언어 레벨에서는 원인을 추적하기 힘들어 보여요. 그래서 바이너리를 디스어셈블 해봤고, 결과는 다음과 같아요.\n; printf(\".2f\", 5/2) mov esi,0x2 lea rax,[rip+0xea7] mov rdi,rax mov eax,0x0 call 0x1050 \u003cprintf@plt\u003e 5/2는 2로 evaluate된 다음 그 결과가 상수로 어셈블리에 기록되었네요. x86-64 calling convention에 맞게 첫 번째 인자인 “%.2f\"를 lea rax, [rip+0xea7]과 mov rdi, rax로 rdi에 넘겨주고, 두 번째 인자인 2를 mov esi, 0x2로 rsi에 넘겨주네요. 이 코드는 너무 obvious하기 때문에 출력값이 달라지는데 영향을 안 줄 것 같아요. 아마 printf의 내부 동작에서 무언가 일어날 것 같아요.\nglibc 분석 printf 함수는 glibc에(설치 직후의 \bUbuntu를 사용했기 때문에 musl libc같은건 확실히 아니었어요) 구현되어 있어요. 우선 printf의 구현은 다음과 같아요.\nint __printf (const char *format, ...) { va_list arg; int done; va_start (arg, format); done = __vfprintf_internal (stdout, format, arg, 0); va_end (arg); return done; } va_list, va_start, va_end를 이용해 가변 인자를 처리하네요. printf는 껍데기에 불과하고, 실질적인 로직은 __vfprintf_internal에 구현되어 있는걸로 보여요. __vfprintf_internal의 구현은 다음과 같아요.\n// ... #if __HAVE_FLOAT128_UNLIKE_LDBL #define PARSE_FLOAT_VA_ARG_EXTENDED(INFO) \\ do { \\ if (is_long_double \u0026\u0026 (mode_flags \u0026 PRINTF_LDBL_USES_FLOAT128) != 0) {\t\\ INFO.is_binary128 = 1; \\ the_arg.pa_float128 = va_arg (ap, _Float128); \\ } else { \\ PARSE_FLOAT_VA_ARG (INFO); \\ } \\ } while (0) #else #define PARSE_FLOAT_VA_ARG_EXTENDED(INFO)\tPARSE_FLOAT_VA_ARG(INFO); #endif // ... #define PARSE_FLOAT_VA_ARG(INFO)\t\\ do { \\ INFO.is_binary128 = 0; \\ if (is_long_double) \\ the_arg.pa_long_double = va_arg (ap, long double); \\ else \\ the_arg.pa_double = va_arg (ap, double); \\ } \\ while (0) // ... int vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags) { LABEL (form_float): LABEL (form_floathex): { // ... PARSE_FLOAT_VA_ARG_EXTENDED (info); // ... } } 주목해야 할 부분은 %f 형식지정자로 값을 넘겨줬을 때 인자를 PARSE_FLOAT_VA_ARG_EXTENDED 매크로로 받아요. PARSE_FLOAT_VA_ARG_EXTENDED매크로는 시스템이 _Float128 지원하는지 확인한 다음 지원한다면 va_arg(ap, _Float128)로 인자를 받아오고, 지원하지 않는다면 PARSE_FLOAT_VA_ARG(INFO) 매크로를 실행해요. PARSE_FLOAT_VA_ARG(INFO)는 또 다시 인자가 long double형인지 확인하여 va_arg(ap, long double) 또는 va_arg(ap, double)중 하나를 실행해요.\n여기까지 printf가 인자를 어떻게 처리하는지 알아봤어요. 지금까지 알아낸 것 중에서 출력 결과를 다르게 하는 원인이 있을거에요. 아마 va_arg로 int 형의 값을 double형으로 읽었을 때 각 환경에서 값을 다르게 표현하는 것 같아요. 그러면 va_arg가 어떻게 작동하는지 알아보기 전에 인자로 5/2가 아니라 5.0/2.0이 제대로 전달되게 하면 어떤 일이 일어나는지 확인해볼까요?\n다시 디스어셈블 %f 형식지정자로 포맷한 printf에 실수형 값을 제대로 입력하면 어떻게 될까요? 디스어셈블 결과는 다음과 같아요.\nmov rax,QWORD PTR [rip+0xeb8] movq xmm0,rax lea rax,[rip+0xea4] mov rdi,rax mov eax,0x1 call 0x1050 \u003cprintf@plt\u003e xmm 레지스터를 이용해 값을 전달하네요. xmm 레지스터는 SSE 확장에 추가된 레지스터로, 부동소수점 관련 연산을 처리하는데 사용돼요.\n저는 여기에서 단서를 얻어 CPU에서 활성화된 확장에 따라 출력 결과가 달라진다는 가설을 세웠고, 진짜 그런지 확인해봤어요.\n유레카 아래는 제 컴퓨터에서 확인한 활성화된 CPU 확장 목록이에요. 아래는 친구의 컴퓨터와 같은 환경에서 확인한 활성화된 CPU 확장 목록이에요. 제 컴퓨터에서는 AVX가 활성되어 있지만 VirtualBox상의 환경에서는 AVX가 비활성화 되어있는 것을 볼 수 있어요. 그러면 x86-64 macOS에 설치된 Parallels에서 AVX를 비활성화 시키면 쓰레기 값이 출력되겠죠? 아쉽게도 Parallels에서 AVX를 비활성화 시키는 방법은 찾지 못했고, 대신 커널 파라미터를 통해 AVX를 비활성화 시키는 방법을 발견해서 한번 시도해봤어요.\n아래는 AVX가 활성화된 Parallels에서 문제의 코드를 실행한 결과예요. 아래는 AVX가 비활성화된 Parallels에서 문제의 코드를 실행한 결과예요. 예상했던대로 AVX가 실행 결과에 영향을 줬어요. 그런데 왜 AVX가 실행 결과에 영향을 줄까요?\n구글링 일단 똑같은 바이너리를 AVX가 활성화된 컴퓨터와 비활성화된 컴퓨터에서 모두 실행했기 때문에 AVX에서 추가된 인스트럭션을 사용하지 않았다고 추정하고, AVX가 활성화되었을 때 동작이 달라지는 인스트럭션에 대해 구글링했어요. 그리고 \bCVTSS2SD라는 듣도보도못한 괴상한 인스트럭션을 발견했어요.\nSSE2만 활성화 되었을 때에는 xmm2 레지스터의 단정밀도 부동소수점 값을 xmm1 레지스터에 배정밀도 부동소수점으로 변환하여 저장해요. 그리고 AVX가 활성화 되었을 때에는 xmm3 레지스터의 단정밀도 부동소수점 값을 xmm2 레지스터에 배정밀도 부동소수점으로 변환하여 저장하고, high bits를 0으로 채워요.\n마지막 퍼즐 조각 C99 표준 문서 6.5.2.2 Function calls와 7.15.1 Variable argument list access macros를 보면 default argument promotions에 의해 가변인자로 float형을 전달하면 무조건 double형으로 변환되게 되어있어요. 형 변환시 float형을 무작정 32비트에서 64비트로 크기만 키우면 값이 깨지기 때문에 CVTSS2SD라는 인스트럭션을 이용해 형변환을 하고, AVX에 활성화에 따라 CVTSS2SD 인스트럭션의 동작이 다르기 때문에 환경에 따라 다른 값이 출력되는걸로 보여요. 실제로…\n🚧 작성 중… 빠른 시일 내로 글을 마무리하겠습니다!\n","wordCount":"842","inLanguage":"en","datePublished":"2023-03-28T19:54:02+09:00","dateModified":"2023-03-28T19:54:02+09:00","author":{"@type":"Person","name":"Sangwon Ryu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.sryu.dev/post/avx%EA%B0%80-%EC%8F%98%EC%95%84%EC%98%AC%EB%A6%B0-%EC%9E%91%EC%9D%80-ub/"},"publisher":{"@type":"Organization","name":"blog.sryu.dev","logo":{"@type":"ImageObject","url":"https://blog.sryu.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.sryu.dev/ accesskey=h title="blog.sryu.dev (Alt + H)">blog.sryu.dev</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://blog.sryu.dev/search/ title="검색 (Alt + /)" accesskey=/><span>검색</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">AVX가 쏘아올린 작은 UB</h1><div class=post-meta><span title='2023-03-28 19:54:02 +0900 KST'>March 28, 2023</span>&nbsp;·&nbsp;Sangwon Ryu</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#시작하기-전에>시작하기 전에&mldr;</a></li><li><a href=#사건의-발단>사건의 발단</a></li><li><a href=#원인-분석>원인 분석</a></li><li><a href=#디스어셈블>디스어셈블</a></li><li><a href=#glibc-분석>glibc 분석</a></li><li><a href=#다시-디스어셈블>다시 디스어셈블</a></li><li><a href=#유레카>유레카</a></li><li><a href=#구글링>구글링</a></li><li><a href=#마지막-퍼즐-조각>마지막 퍼즐 조각</a></li></ul></nav></div></details></div><div class=post-content><h2 id=시작하기-전에>시작하기 전에&mldr;<a hidden class=anchor aria-hidden=true href=#시작하기-전에>#</a></h2><p>사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 &lsquo;요즘&rsquo;은 2023년 3월 말을 의미해요.</p><h2 id=사건의-발단>사건의 발단<a hidden class=anchor aria-hidden=true href=#사건의-발단>#</a></h2><p>요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%f&#34;</span>, <span style=color:#ae81ff>5</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span></code></pre></div><p>교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.5가 아니라 정수형 2라고 하시면서 <code>printf</code>가 <code>%f</code> 형식 지정자때문에 두 번째 인자로 double형의 값이 오기를 기대했는데, 예기치 않은 int형의 값이 전달됐기 때문에 0.0이 출력된다고 하셨어요.</p><p>어라, 제 컴퓨터에서는 0.0이 출력되는데&mldr;</p><p><img loading=lazy src=/images/Pasted%20image%2020240218015629.png alt="내 컴퓨터에서 실행한 결과"></p><p>친구의 컴퓨터에서 실행했을 때는 이상한 쓰레기값이 출력되네요?</p><p><img loading=lazy src=/images/Pasted%20image%2020240218015835.png alt="친구의 컴퓨터와 똑같은 환경에서 실행한 결과"></p><h2 id=원인-분석>원인 분석<a hidden class=anchor aria-hidden=true href=#원인-분석>#</a></h2><p>어떠한 요인이 다른 출력 결과를 유발시키는지 확인하기 위해 제 환경과 친구 환경의 차이점을 비교해봤어요. 우분투 버전, glibc 버전 모두 동일했어요. 저는 x86-64 macOS를 사용하고 있었고, 친구는 x86-64 Windows 머신 위에 x86-64 Ubuntu 게스트를 설치해 사용하고 있었어요. macOS와 Ubuntu의 차이 때문인지 확인하기 위해 x86-64 macOS에서 Parallels로 x86-64 Ubuntu 게스트를 설치해 테스트했고, 마찬가지로 제 환경에서는 0.0이 출력됐어요. 혹시 가상머신의 특성을 타는건가 싶어 친구가 사용하는 VirtualBox를 설치해 위의 코드를 실행해봤고 예상했던대로 쓰레기값이 출력됐어요. 가상머신의 특성을 탄다는건 알게 됐는데, 정확히 각 가상머신의 어떤 요소가 다른 출력값을 야기했을까요?</p><h2 id=디스어셈블>디스어셈블<a hidden class=anchor aria-hidden=true href=#디스어셈블>#</a></h2><p>우선 동일한 바이너리를 다른 가상머신에서 실행했을 때 출력값이 달라지기 때문에 C언어 레벨에서는 원인을 추적하기 힘들어 보여요. 그래서 바이너리를 디스어셈블 해봤고, 결과는 다음과 같아요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#75715e>; printf(&#34;.2f&#34;, 5/2)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>esi</span>,<span style=color:#ae81ff>0x2</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lea</span>    <span style=color:#66d9ef>rax</span>,[<span style=color:#66d9ef>rip</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0xea7</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>rdi</span>,<span style=color:#66d9ef>rax</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>eax</span>,<span style=color:#ae81ff>0x0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span>   <span style=color:#ae81ff>0x1050</span> &lt;<span style=color:#66d9ef>printf@plt</span>&gt;
</span></span></code></pre></div><p>5/2는 2로 evaluate된 다음 그 결과가 상수로 어셈블리에 기록되었네요. x86-64 calling convention에 맞게 첫 번째 인자인 &ldquo;%.2f"를 <code>lea rax, [rip+0xea7]</code>과 <code>mov rdi, rax</code>로 rdi에 넘겨주고, 두 번째 인자인 2를 <code>mov esi, 0x2</code>로 rsi에 넘겨주네요. 이 코드는 너무 obvious하기 때문에 출력값이 달라지는데 영향을 안 줄 것 같아요. 아마 <code>printf</code>의 내부 동작에서 무언가 일어날 것 같아요.</p><h2 id=glibc-분석>glibc 분석<a hidden class=anchor aria-hidden=true href=#glibc-분석>#</a></h2><p><code>printf</code> 함수는 glibc에(설치 직후의 Ubuntu를 사용했기 때문에 musl libc같은건 확실히 아니었어요) 구현되어 있어요. 우선 <code>printf</code>의 구현은 다음과 같아요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>__printf</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format, ...) {
</span></span><span style=display:flex><span>    va_list arg;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> done;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>va_start</span> (arg, format);
</span></span><span style=display:flex><span>    done <span style=color:#f92672>=</span> <span style=color:#a6e22e>__vfprintf_internal</span> (stdout, format, arg, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>va_end</span> (arg);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> done;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>va_list</code>, <code>va_start</code>, <code>va_end</code>를 이용해 가변 인자를 처리하네요. printf는 껍데기에 불과하고, 실질적인 로직은 <code>__vfprintf_internal</code>에 구현되어 있는걸로 보여요. <code>__vfprintf_internal</code>의 구현은 다음과 같아요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if __HAVE_FLOAT128_UNLIKE_LDBL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>#define PARSE_FLOAT_VA_ARG_EXTENDED(INFO) 										\
</span></span></span><span style=display:flex><span><span style=color:#75715e>	    do { 																		\
</span></span></span><span style=display:flex><span><span style=color:#75715e>	        if (is_long_double &amp;&amp; (mode_flags &amp; PRINTF_LDBL_USES_FLOAT128) != 0) {	\
</span></span></span><span style=display:flex><span><span style=color:#75715e>				INFO.is_binary128 = 1; 												\
</span></span></span><span style=display:flex><span><span style=color:#75715e>				the_arg.pa_float128 = va_arg (ap, _Float128); 						\
</span></span></span><span style=display:flex><span><span style=color:#75715e>			} else { 																\
</span></span></span><span style=display:flex><span><span style=color:#75715e>				PARSE_FLOAT_VA_ARG (INFO); 											\
</span></span></span><span style=display:flex><span><span style=color:#75715e>			} 																		\
</span></span></span><span style=display:flex><span><span style=color:#75715e>		} while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>#define PARSE_FLOAT_VA_ARG_EXTENDED(INFO)	PARSE_FLOAT_VA_ARG(INFO);
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define PARSE_FLOAT_VA_ARG(INFO)								\
</span></span></span><span style=display:flex><span><span style=color:#75715e>    do {                                                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        INFO.is_binary128 = 0;                                  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        if (is_long_double)                                     \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            the_arg.pa_long_double = va_arg (ap, long double);  \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        else                                                    \
</span></span></span><span style=display:flex><span><span style=color:#75715e>            the_arg.pa_double = va_arg (ap, double);            \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }                                                           \
</span></span></span><span style=display:flex><span><span style=color:#75715e>    while (0)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>vfprintf</span> (FILE <span style=color:#f92672>*</span>s, <span style=color:#66d9ef>const</span> CHAR_T <span style=color:#f92672>*</span>format, va_list ap, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> mode_flags) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>LABEL</span> (form_float)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>LABEL</span> (form_floathex)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#a6e22e>PARSE_FLOAT_VA_ARG_EXTENDED</span> (info);
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>주목해야 할 부분은 <code>%f</code> 형식지정자로 값을 넘겨줬을 때 인자를 <code>PARSE_FLOAT_VA_ARG_EXTENDED</code> 매크로로 받아요. <code>PARSE_FLOAT_VA_ARG_EXTENDED</code>매크로는 시스템이 <code>_Float128</code> 지원하는지 확인한 다음 지원한다면 <code>va_arg(ap, _Float128)</code>로 인자를 받아오고, 지원하지 않는다면 <code>PARSE_FLOAT_VA_ARG(INFO)</code> 매크로를 실행해요. <code>PARSE_FLOAT_VA_ARG(INFO)</code>는 또 다시 인자가 <code>long double</code>형인지 확인하여 <code>va_arg(ap, long double)</code> 또는 <code>va_arg(ap, double)</code>중 하나를 실행해요.</p><p>여기까지 <code>printf</code>가 인자를 어떻게 처리하는지 알아봤어요. 지금까지 알아낸 것 중에서 출력 결과를 다르게 하는 원인이 있을거에요. 아마 <code>va_arg</code>로 int 형의 값을 double형으로 읽었을 때 각 환경에서 값을 다르게 표현하는 것 같아요. 그러면 <code>va_arg</code>가 어떻게 작동하는지 알아보기 전에 인자로 <code>5/2</code>가 아니라 <code>5.0/2.0</code>이 제대로 전달되게 하면 어떤 일이 일어나는지 확인해볼까요?</p><h2 id=다시-디스어셈블>다시 디스어셈블<a hidden class=anchor aria-hidden=true href=#다시-디스어셈블>#</a></h2><p><code>%f</code> 형식지정자로 포맷한 <code>printf</code>에 실수형 값을 제대로 입력하면 어떻게 될까요? 디스어셈블 결과는 다음과 같아요.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>rax</span>,<span style=color:#66d9ef>QWORD</span> <span style=color:#66d9ef>PTR</span> [<span style=color:#66d9ef>rip</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0xeb8</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>movq</span>   <span style=color:#66d9ef>xmm0</span>,<span style=color:#66d9ef>rax</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lea</span>    <span style=color:#66d9ef>rax</span>,[<span style=color:#66d9ef>rip</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>0xea4</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>rdi</span>,<span style=color:#66d9ef>rax</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>eax</span>,<span style=color:#ae81ff>0x1</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span>   <span style=color:#ae81ff>0x1050</span> &lt;<span style=color:#66d9ef>printf@plt</span>&gt;
</span></span></code></pre></div><p>xmm 레지스터를 이용해 값을 전달하네요. xmm 레지스터는 SSE 확장에 추가된 레지스터로, 부동소수점 관련 연산을 처리하는데 사용돼요.</p><p>저는 여기에서 단서를 얻어 CPU에서 활성화된 확장에 따라 출력 결과가 달라진다는 가설을 세웠고, 진짜 그런지 확인해봤어요.</p><h2 id=유레카>유레카<a hidden class=anchor aria-hidden=true href=#유레카>#</a></h2><p>아래는 제 컴퓨터에서 확인한 활성화된 CPU 확장 목록이에요.
<img loading=lazy src=/images/telegram-cloud-photo-size-5-6132179513400997680-y.jpg alt="내 컴퓨터에서 확인한 CPU 확장"></p><p>아래는 친구의 컴퓨터와 같은 환경에서 확인한 활성화된 CPU 확장 목록이에요.
<img loading=lazy src=/images/telegram-cloud-photo-size-5-6132179513400997681-x.jpg alt="친구의 컴퓨터와 똑같은 환경에서 확인한 CPU 확장"></p><p>제 컴퓨터에서는 AVX가 활성되어 있지만 VirtualBox상의 환경에서는 AVX가 비활성화 되어있는 것을 볼 수 있어요. 그러면 x86-64 macOS에 설치된 Parallels에서 AVX를 비활성화 시키면 쓰레기 값이 출력되겠죠? 아쉽게도 Parallels에서 AVX를 비활성화 시키는 방법은 찾지 못했고, 대신 <a href=https://stackoverflow.com/questions/13965178/how-do-i-disable-avx-instructions-on-a-linux-computer>커널 파라미터</a>를 통해 AVX를 비활성화 시키는 방법을 발견해서 한번 시도해봤어요.</p><p>아래는 AVX가 활성화된 Parallels에서 문제의 코드를 실행한 결과예요.
<img loading=lazy src=/images/telegram-cloud-photo-size-5-6132179513400997687-y.jpg alt="AVX가 활성화된 Parallels에서의 결과"></p><p>아래는 AVX가 비활성화된 Parallels에서 문제의 코드를 실행한 결과예요.
<img loading=lazy src=/images/telegram-cloud-photo-size-5-6132179513400997688-y.jpg alt="AVX가 비활성화된 Parallels에서의 결과">
예상했던대로 AVX가 실행 결과에 영향을 줬어요. 그런데 왜 AVX가 실행 결과에 영향을 줄까요?</p><h2 id=구글링>구글링<a hidden class=anchor aria-hidden=true href=#구글링>#</a></h2><p>일단 똑같은 바이너리를 AVX가 활성화된 컴퓨터와 비활성화된 컴퓨터에서 모두 실행했기 때문에 AVX에서 추가된 인스트럭션을 사용하지 않았다고 추정하고, AVX가 활성화되었을 때 동작이 달라지는 인스트럭션에 대해 구글링했어요. 그리고 <a href=https://modoocode.com/en/inst/cvtss2sd><code>CVTSS2SD</code></a>라는 듣도보도못한 괴상한 인스트럭션을 발견했어요.</p><p><img loading=lazy src=/images/Pasted%20image%2020240218024606.png alt=CVTSS2SD></p><p>SSE2만 활성화 되었을 때에는 xmm2 레지스터의 단정밀도 부동소수점 값을 xmm1 레지스터에 배정밀도 부동소수점으로 변환하여 저장해요. 그리고 AVX가 활성화 되었을 때에는 xmm3 레지스터의 단정밀도 부동소수점 값을 xmm2 레지스터에 배정밀도 부동소수점으로 변환하여 저장하고, high bits를 0으로 채워요.</p><h2 id=마지막-퍼즐-조각>마지막 퍼즐 조각<a hidden class=anchor aria-hidden=true href=#마지막-퍼즐-조각>#</a></h2><p><a href=https://open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf>C99 표준 문서</a> <code>6.5.2.2 Function calls</code>와 <code>7.15.1 Variable argument list access macros</code>를 보면 <code>default argument promotions</code>에 의해 가변인자로 float형을 전달하면 무조건 double형으로 변환되게 되어있어요. 형 변환시 float형을 무작정 32비트에서 64비트로 크기만 키우면 값이 깨지기 때문에 CVTSS2SD라는 인스트럭션을 이용해 형변환을 하고, AVX에 활성화에 따라 CVTSS2SD 인스트럭션의 동작이 다르기 때문에 환경에 따라 다른 값이 출력되는걸로 보여요. 실제로&mldr;</p><h1 id=-작성-중>🚧 작성 중&mldr;<a hidden class=anchor aria-hidden=true href=#-작성-중>#</a></h1><p>빠른 시일 내로 글을 마무리하겠습니다!</p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://utteranc.es/client.js repo=sangwon090/blog.sryu.dev issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://blog.sryu.dev/>blog.sryu.dev</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>