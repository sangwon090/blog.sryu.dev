[{"content":"시작하기 전에\u0026hellip; 사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 \u0026lsquo;요즘\u0026rsquo;은 2023년 3월 말을 의미해요.\n사건의 발단 요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.\nprintf(\u0026#34;%f\u0026#34;, 5 / 2); 교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.5가 아니라 정수형 2라고 하시면서 printf가 %f 형식 지정자때문에 두 번째 인자로 double형의 값이 오기를 기대했는데, 예기치 않은 int형의 값이 전달됐기 때문에 0.0이 출력된다고 하셨어요.\n어라, 제 컴퓨터에서는 0.0이 출력되는데\u0026hellip;\n친구의 컴퓨터에서 실행했을 때는 이상한 쓰레기값이 출력되네요?\n원인 분석 어떠한 요인이 다른 출력 결과를 유발시키는지 확인하기 위해 제 환경과 친구 환경의 차이점을 비교해봤어요. 우분투 버전, glibc 버전 모두 동일했어요. 저는 x86-64 macOS를 사용하고 있었고, 친구는 x86-64 Windows 머신 위에 x86-64 Ubuntu 게스트를 설치해 사용하고 있었어요. macOS와 Ubuntu의 차이 때문인지 확인하기 위해 x86-64 macOS에서 Parallels로 x86-64 Ubuntu 게스트를 설치해 테스트했고, 마찬가지로 제 환경에서는 0.0이 출력됐어요. 혹시 가상머신의 특성을 타는건가 싶어 친구가 사용하는 VirtualBox를 설치해 위의 코드를 실행해봤고 예상했던대로 쓰레기값이 출력됐어요. 가상머신의 특성을 탄다는건 알게 됐는데, 정확히 각 가상머신의 어떤 요소가 다른 출력값을 야기했을까요?\n디스어셈블 우선 동일한 바이너리를 다른 가상머신에서 실행했을 때 출력값이 달라지기 때문에 C언어 레벨에서는 원인을 추적하기 힘들어 보여요. 그래서 바이너리를 디스어셈블 해봤고, 결과는 다음과 같아요.\n; printf(\u0026#34;.2f\u0026#34;, 5/2) mov esi,0x2 lea rax,[rip+0xea7] mov rdi,rax mov eax,0x0 call 0x1050 \u0026lt;printf@plt\u0026gt; 5/2는 2로 evaluate된 다음 그 결과가 상수로 어셈블리에 기록되었네요. x86-64 calling convention에 맞게 첫 번째 인자인 \u0026ldquo;%.2f\u0026quot;를 lea rax, [rip+0xea7]과 mov rdi, rax로 rdi에 넘겨주고, 두 번째 인자인 2를 mov esi, 0x2로 rsi에 넘겨주네요. 이 코드는 너무 obvious하기 때문에 출력값이 달라지는데 영향을 안 줄 것 같아요. 아마 printf의 내부 동작에서 무언가 일어날 것 같아요.\nglibc 분석 printf 함수는 glibc에(설치 직후의 \bUbuntu를 사용했기 때문에 musl libc같은건 확실히 아니었어요) 구현되어 있어요. 우선 printf의 구현은 다음과 같아요.\nint __printf (const char *format, ...) { va_list arg; int done; va_start (arg, format); done = __vfprintf_internal (stdout, format, arg, 0); va_end (arg); return done; } va_list, va_start, va_end를 이용해 가변 인자를 처리하네요. printf는 껍데기에 불과하고, 실질적인 로직은 __vfprintf_internal에 구현되어 있는걸로 보여요. __vfprintf_internal의 구현은 다음과 같아요.\n// ... #if __HAVE_FLOAT128_UNLIKE_LDBL #define PARSE_FLOAT_VA_ARG_EXTENDED(INFO) \\ do { \\ if (is_long_double \u0026amp;\u0026amp; (mode_flags \u0026amp; PRINTF_LDBL_USES_FLOAT128) != 0) {\t\\ INFO.is_binary128 = 1; \\ the_arg.pa_float128 = va_arg (ap, _Float128); \\ } else { \\ PARSE_FLOAT_VA_ARG (INFO); \\ } \\ } while (0) #else #define PARSE_FLOAT_VA_ARG_EXTENDED(INFO)\tPARSE_FLOAT_VA_ARG(INFO); #endif // ... #define PARSE_FLOAT_VA_ARG(INFO)\t\\ do { \\ INFO.is_binary128 = 0; \\ if (is_long_double) \\ the_arg.pa_long_double = va_arg (ap, long double); \\ else \\ the_arg.pa_double = va_arg (ap, double); \\ } \\ while (0) // ... int vfprintf (FILE *s, const CHAR_T *format, va_list ap, unsigned int mode_flags) { LABEL (form_float): LABEL (form_floathex): { // ... PARSE_FLOAT_VA_ARG_EXTENDED (info); // ... } } 주목해야 할 부분은 %f 형식지정자로 값을 넘겨줬을 때 인자를 PARSE_FLOAT_VA_ARG_EXTENDED 매크로로 받아요. PARSE_FLOAT_VA_ARG_EXTENDED매크로는 시스템이 _Float128 지원하는지 확인한 다음 지원한다면 va_arg(ap, _Float128)로 인자를 받아오고, 지원하지 않는다면 PARSE_FLOAT_VA_ARG(INFO) 매크로를 실행해요. PARSE_FLOAT_VA_ARG(INFO)는 또 다시 인자가 long double형인지 확인하여 va_arg(ap, long double) 또는 va_arg(ap, double)중 하나를 실행해요.\n여기까지 printf가 인자를 어떻게 처리하는지 알아봤어요. 지금까지 알아낸 것 중에서 출력 결과를 다르게 하는 원인이 있을거에요. 아마 va_arg로 int 형의 값을 double형으로 읽었을 때 각 환경에서 값을 다르게 표현하는 것 같아요. 그러면 va_arg가 어떻게 작동하는지 알아보기 전에 인자로 5/2가 아니라 5.0/2.0이 제대로 전달되게 하면 어떤 일이 일어나는지 확인해볼까요?\n다시 디스어셈블 %f 형식지정자로 포맷한 printf에 실수형 값을 제대로 입력하면 어떻게 될까요? 디스어셈블 결과는 다음과 같아요.\nmov rax,QWORD PTR [rip+0xeb8] movq xmm0,rax lea rax,[rip+0xea4] mov rdi,rax mov eax,0x1 call 0x1050 \u0026lt;printf@plt\u0026gt; xmm 레지스터를 이용해 값을 전달하네요. xmm 레지스터는 SSE 확장에 추가된 레지스터로, 부동소수점 관련 연산을 처리하는데 사용돼요.\n저는 여기에서 단서를 얻어 CPU에서 활성화된 확장에 따라 출력 결과가 달라진다는 가설을 세웠고, 진짜 그런지 확인해봤어요.\n유레카 아래는 제 컴퓨터에서 확인한 활성화된 CPU 확장 목록이에요. 아래는 친구의 컴퓨터와 같은 환경에서 확인한 활성화된 CPU 확장 목록이에요. 제 컴퓨터에서는 AVX가 활성되어 있지만 VirtualBox상의 환경에서는 AVX가 비활성화 되어있는 것을 볼 수 있어요. 그러면 x86-64 macOS에 설치된 Parallels에서 AVX를 비활성화 시키면 쓰레기 값이 출력되겠죠? 아쉽게도 Parallels에서 AVX를 비활성화 시키는 방법은 찾지 못했고, 대신 커널 파라미터를 통해 AVX를 비활성화 시키는 방법을 발견해서 한번 시도해봤어요.\n아래는 AVX가 활성화된 Parallels에서 문제의 코드를 실행한 결과예요. 아래는 AVX가 비활성화된 Parallels에서 문제의 코드를 실행한 결과예요. 예상했던대로 AVX가 실행 결과에 영향을 줬어요. 그런데 왜 AVX가 실행 결과에 영향을 줄까요?\n구글링 일단 똑같은 바이너리를 AVX가 활성화된 컴퓨터와 비활성화된 컴퓨터에서 모두 실행했기 때문에 AVX에서 추가된 인스트럭션을 사용하지 않았다고 추정하고, AVX가 활성화되었을 때 동작이 달라지는 인스트럭션에 대해 구글링했어요. 그리고 \bCVTSS2SD라는 듣도보도못한 괴상한 인스트럭션을 발견했어요.\nSSE2만 활성화 되었을 때에는 xmm2 레지스터의 단정밀도 부동소수점 값을 xmm1 레지스터에 배정밀도 부동소수점으로 변환하여 저장해요. 그리고 AVX가 활성화 되었을 때에는 xmm3 레지스터의 단정밀도 부동소수점 값을 xmm2 레지스터에 배정밀도 부동소수점으로 변환하여 저장하고, high bits를 0으로 채워요.\n마지막 퍼즐 조각 C99 표준 문서 6.5.2.2 Function calls와 7.15.1 Variable argument list access macros를 보면 default argument promotions에 의해 가변인자로 float형을 전달하면 무조건 double형으로 변환되게 되어있어요. 형 변환시 float형을 무작정 32비트에서 64비트로 크기만 키우면 값이 깨지기 때문에 CVTSS2SD라는 인스트럭션을 이용해 형변환을 하고, AVX에 활성화에 따라 CVTSS2SD 인스트럭션의 동작이 다르기 때문에 환경에 따라 다른 값이 출력되는걸로 보여요. 실제로\u0026hellip;\n🚧 작성 중\u0026hellip; 빠른 시일 내로 글을 마무리하겠습니다!\n","permalink":"https://blog.sryu.dev/post/avx%EA%B0%80-%EC%8F%98%EC%95%84%EC%98%AC%EB%A6%B0-%EC%9E%91%EC%9D%80-ub/","summary":"시작하기 전에\u0026hellip; 사실 이 글은 2023년 3월 말에 초안을 완성했는데, 게으름 이슈로 약 1년 가량이 지난 다음에서야 다듬어서 업로드 하게 됐어요. 그래서 이 글에서 지칭하는 \u0026lsquo;요즘\u0026rsquo;은 2023년 3월 말을 의미해요.\n사건의 발단 요즘 학교에서 C언어를 배우고 있어요. 교수님께서 기초적인 C언어 문법만으로는 학생들을 변별하기 어려워서인지 Undefined Behaviour이 잔뜩 포함되어 아리까리한 내용을 많이 가르치시고 있어요. 하루는 교수님이 다음과 같은 코드를 보여주셨어요.\nprintf(\u0026#34;%f\u0026#34;, 5 / 2); 교수님께서 5 / 2는 양쪽 모두 int형이기 때문에 연산 결과가 실수형 2.","title":"\bAVX가 쏘아올린 작은 UB"},{"content":"고등학교 2학년 때 한컴타자연습 리소스에 이스터에그가 숨겨져 있다는 사실을 우연히 알게 됐는데요, 이스터에그가 더미 데이터로만 존재하는지, 아니면 프로그램 상에서 띄우는 방법이 따로 있는지 궁금해서 한컴타자연습을 리버싱 했었습니다. 프로그램 구조가 많이 단순해 이스터에그를 띄우는 키 조합을 금방 알아낼 수 있었고, 리버싱 결과를 페이스북의 코딩이랑 무관합니다만 그룹에 올려놨습니다.\n블로그를 개설한 지 한 달 정도 됐는데, 뭐라도 올려야 될 것 같아서 키 조합을 어떻게 알아냈는지 리버싱 과정을 정리해서 올려볼려고 합니다. 2년 전에 리버싱 과정을 따로 기록해두지 않아 이번에 리버싱을 다시 했는데, 재작년에 발견하지 못한 또 다른 키 조합도 발견했네요.\n시작하기 전에 이 글은 한컴타자연습 2005를 기준으로 작성되었습니다. 2002, 2004 버전의 경우 아마도 큰 차이점은 없을텐데 함수의 이름이ㅇ 다를겁니다. 참고로 2007 버전에서는 이스터에그 관련 코드가 제거되었습니다.\n프로그램이 단순해서 리버싱을 제대로 공부해본 적이 없었지만, IDA의 디컴파일러만으로 이스터에그를 쉽게 찾을 수 있었습니다. 리버싱에 관심이 있으신 분은 제 글을 읽기 전에 한번 직접 해보는 것도 나쁘지 않을 것 같습니다.\n리소스 훑어보기 어떤 이스터에그가 있는지 한 번 살펴볼까요?\n첫 번째 이스터에그 169 (0xA9) 두 번째 이스터에그 346 (0x15A) 프로그램 개발이 수능에까지 영향을 미쳤다는 부분이 인상적이네요.\n이스터에그를 표시하는 코드 LoadImageA 프로그램 전체를 분석하는 것 보다 이스터에그와 연관된 부분만 분석하는게 훨씬 효율적이겠죠? 이스터에그를 화면에 띄우려면 이미지를 불러오는 함수를 호출할 수 밖에 없을 것입니다. 그러므로 LoadImageA 함수의 크로스 레퍼런스를 분석하는 것에서 시작해봅시다.\n4개의 xref를 가지고 있네요. 하나씩 확인해봅시다.\nsub_4069A0의 디컴파일 결과입니다.\nHANDLE __cdecl sub_4069A0(LPCSTR name, _DWORD *a2) { HANDLE result; // eax CHAR Text[256]; // [esp+8h] [ebp-100h] BYREF *a2 = 0; result = LoadImageA(hInst, name, 0, 0, 0, 0x10u); *a2 = result; if ( !result ) { sprintf(Text, aS_0, name); return (HANDLE)MessageBoxA(0, Text, aLoad, 0); } return result; } LoadImageA의 5번째 인자로 LR_LOADFROMFILE (0x10)을 넘기네요. name 으로 넘어온 이름을 가진 파일을 로드하고 리턴하는 함수로 보입니다. 이스터에그 이미지가 리소스에 있을 뿐더러, sub_4096A0의 xref가 WinMain+22F에 있는 sub_4069A0(aHnctlogoSys, \u0026amp;dword_932120);밖에 없는 것으로 봤을 때 로고를 로드하는 함수인 것으로 보입니다. 패스하겠습니다.\nsub_406A10의 디컴파일 결과입니다.\nHANDLE __cdecl sub_406A10(LPCSTR name, _DWORD *a2) { HANDLE result; // eax CHAR Text[256]; // [esp+8h] [ebp-100h] BYREF *a2 = 0; result = LoadImageA(hInst, name, 0, 0, 0, 0x2000u); *a2 = result; if ( !result ) { sprintf(Text, aS_0, name); return (HANDLE)MessageBoxA(0, Text, aLoad, 0); } return result; } sub_406910과 거의 똑같네요. 딱 한가지만 다릅니다. LoadImageA의 5번째 인자로 LR_CREATEDIBSECTION (0x2000)를 넘깁니다. xref가 172개나 되네요. LoadImageA의 xref 2개를 더 분석하고, 이스터에그와 연관이 없다고 보이면 그 때 다시 분석하겠습니다.\nWinMain+BA의 디컴파일 결과입니다.\nv18.hIconSm = (HICON)LoadImageA(hInst, name, 1u, 16, 16, 0); 아이콘을 불러오는 코드입니다. 패스합니다.\nWinMain+의 디컴파일 결과입니다.\nv19.hIconSm = (HICON)LoadImageA(hInst, name, 1u, 16, 16, 0); 이것도 아이콘을 불러오는 코드입니다. 되돌아가서 sub_406A10의 xref를 분석해봅시다.\nsub_406A10 xref가 172개나 돼서 앞이 캄캄했는데, 모두 sub_41CF80이라는 함수에서 호출되네요. 다행입니다.\nsub_41CF80 HANDLE sub_41CF80() { sub_406A10((LPCSTR)0x14C, \u0026amp;dword_C278E4); sub_406A10((LPCSTR)0x75, \u0026amp;dword_C2796C); sub_406A10((LPCSTR)0xAF, \u0026amp;dword_C0E8C4); // ... sub_406A10((LPCSTR)0xA9, \u0026amp;dword_C29B40); sub_406A10((LPCSTR)0x15A, \u0026amp;dword_C278E0); // ... sub_406A10((LPCSTR)0x14B, \u0026amp;dword_9305F4); sub_406A10((LPCSTR)0x153, \u0026amp;dword_45B37C); return sub_406A10((LPCSTR)0x158, \u0026amp;dword_461E6C); } 아까 리소스해커로 봤듯이, 이스터에그의 리소스 id가 169 (0xA9)와 346 (0x15A)였습니다. 리소스가 sub_406A10 함수로 로드되어 dword_C29B40과 dword_C278E0에 저장되는 것 같습니다. 이 주소에 접근하는 코드를 분석하면 이스터에그 발동 조건을 알아낼 수 있을 것입니다.\ndword_C29B40 첫 번째 xref는 방금 분석했던 함수이고, 두 번째 xref는 sub_41D9D0에 있는 DeleteObject(dword_C29B40);입니다. 세 번째, 네 번째 xref는 sub_41F5D0에 있고, 둘 다 이스터에그 이미지를 띄우는 부분으로 추정됩니다.\n이스터에그를 발동시키는 로직 sub_41F5D0 (1) 필요 없는 부분은 생략했습니다.\nv3 = GetAsyncKeyState; // \u0026lt;-- v3을 주목해주세요. while ( 1 ) { // ... if ( (int (*)())dword_A570EC != sub_41CC30 ) { dword_A570EC = (int)sub_41CC30; sub_41CE50(); } v4 = sub_41F340(); // \u0026lt;-- v4를 주목해주세요. String[0] = 0; sub_4097F0(-100, -100, 0, (wchar_t *)String, 0); if ( v4 == 8 \u0026amp;\u0026amp; v3(17) \u0026amp;\u0026amp; v3(16) ) ++v41; if ( v41 \u0026lt;= 11 ) goto LABEL_50; if ( v4 == 73 ) ++v40; if ( v40 \u0026gt; 0 ) { if ( v4 == 78 ) ++v38; if ( v38 \u0026gt; 1 \u0026amp;\u0026amp; v4 == 79 ) ++v39; } if ( v39 \u0026lt;= 0 ) goto LABEL_50; if ( v39 \u0026gt;= 10 ) { if ( v4 == 8 ) { if ( !v3(17) || !v3(16) ) goto LABEL_50; sub_406910(dword_C278E0, 100, 100); // \u0026lt;-- 두 번째 이스터에그 표시 while ( (sub_41F340() \u0026amp; 0x80000000) != 0 ); } else { if ( v4 != 65 || !v3(83) || !v3(69) || !v3(32) || !v3(16) || v3(17) ) goto LABEL_50; sub_406910(dword_C278E0, 100, 100); // \u0026lt;-- 두 번째 이스터에그 표시 while ( (sub_41F340() \u0026amp; 0x80000000) != 0 ); } dword_A570EC = (int)sub_40E030; sub_41CE50(); dword_45B36C = 1; } else { if ( v4 == 8 ) { if ( !v3(17) || !v3(16) ) goto LABEL_50; sub_406910(dword_C29B40, 100, 100); // \u0026lt;-- 첫 번째 이스터에그 표시 while ( (sub_41F340() \u0026amp; 0x80000000) != 0 ); } else { if ( v4 != 65 || !v3(83) || !v3(69) || !v3(32) || !v3(16) || v3(17) ) goto LABEL_50; sub_406910(dword_C29B40, 100, 100); // \u0026lt;-- 첫 번째 이스터에그 표시 while ( (sub_41F340() \u0026amp; 0x80000000) != 0 ); } dword_A570EC = (int)sub_40E030; sub_41CE50(); } LABEL_50: // ... } 복잡해보이네요. 차근차근 분석해봅시다. 우선, 이스터에그 발동 조건이 충족되지 않으면 goto LABEL_50; 을 통해 키 조합을 검사하는 코드를 건너 뛰는 것으로 보입니다. sub_406910(dword_C29B40, 100, 100);가 이스터에그를 표시하는 함수로 보이네요. 어떤 조건일 때 호출되는지 확인해봅시다.\nif ( v39 \u0026gt;= 10 ) // 두 번째 이스터에그 else if(v4 == 8) if(!v3(17) || !v3(16)) goto LABEL_50; sub_406910(dword_C29B40, 100, 100); else if (v4 != 65 || !v3(83) || !v3(69) || !v3(32) || !v3(16) || v3(17)) goto LABEL_50; sub_406910(dword_C29B40, 100, 100); v3, v4가 무엇인지 알아야겠죠?\nv3 = GetAsyncKeyState; v3은 GetAsyncKeyState를 가리킵니다. MSDN의 GetAsyncKeyState 문서에 따르면, 함수가 호출된 시점에 인자로 받은 가상 키 코드에 해당하는 키가 눌려있으면 적절한 값을 리턴한다고 합니다. 가상 키 코드에 대한 정보는 MSDN의 Virtual-Key Codes 문서를 참고하세요.\nv4 = sub_41F340(); v4는 sub_41F340 함수의 리턴값을 저장하네요. 자세히 분석해봅시다.\nsub_41F340 WPARAM sub_41F340() { // ... while ( 1 ) { // ... if ( message == 256 ) { v1 = sub_409550(Msg.wParam) == 0; result = Msg.wParam; if ( v1 ) { switch ( Msg.wParam ) { case 8u: case 9u: case 0xDu: case 0x15u: case 0x1Bu: case 0x21u: case 0x22u: case 0x25u: case 0x26u: case 0x27u: case 0x28u: case 0x2Eu: return result; default: goto LABEL_14; } } return result; } LABEL_14: // ... } // ... return -2; } 메시지 코드가 WM_KEYDOWN (256)일 때 wParam을 통해 어떤 키가 눌렸는지 알아냅니다. 키 코드가 VK_BACK(8), VK_TAB(9), VK_ENTER(0xD), VK_HANGUL(0x15), VK_ESCAPE(0x1B), VK_PRIOR(0x21), VK_NEXT(0x22), VK_LEFT(0x25), VK_UP(0x26), VK_RIGHT(0x27), VK_DOWN(0x28), VK_DELETE(0x2E) 중 하나라면 그 키 코드를 리턴합니다.\nsub_41F5D0 (2) v39가 무엇인지 확인해봅시다.\nif ( v4 == 8 \u0026amp;\u0026amp; v3(17) \u0026amp;\u0026amp; v3(16) ) ++v41; if ( v41 \u0026lt;= 11 ) goto LABEL_50; if ( v4 == 73 ) ++v40; if ( v40 \u0026gt; 0 ) if ( v4 == 78 ) ++v38; if ( v38 \u0026gt; 1 \u0026amp;\u0026amp; v4 == 79 ) ++v39; if ( v39 \u0026lt;= 0 ) goto LABEL_50; v3과 v4가 무엇인지 이미 분석을 해놨기 때문에 어떤 로직인지 간단하게 파악할 수 있을 것 같습니다. 위에서부터 하나씩 분석해보겠습니다.\nVK_CONTROL(17)과 VK_SHIFT(16)이 눌려있는 상태로 VK_BACK(8)을 누르면 v41 값이 1만큼 증가합니다.\nv41이 11 이하라면 goto LABEL_50;을 통해 키 조합을 확인하는 로직을 벗어납니다. 즉, Control키와 Shift키를 누른 상태에서 Backspace를 12번 이상 눌러야 나머지 코드가 실행됩니다.\nI(73)를 누르면 v40 값이 1 증가합니다.\nv40가 0을 초과하는 상태에서, 다시 말해 I를 1회 이상 누른 상태에서 N(78)을 누르면 v38의 값이 1만큼 증가합니다.\nv38이 1을 초과하는 상태에서, 다시 말해 N을 2회 이상 누른 상태에서 O(79)를 누르면 v39의 값이 1 증가합니다.\n여기까지가 두 이스터에그 모두에 해당하는 키 조합입니다. 정리하자면 Ctrl + Shift를 누른 상태에서 Backspace를 12번 이상 누르고, I 1번 이상, N 2번 이상, O 1번 이상 누르면 됩니다. 그런데 INNO가 무슨 의미일까요? 이스터에그에 나오는 개발자의 이메일 주소가 innoboy@nownuri.net인 것으로 보아 개발자가 사용하는 id의 앞부분인 것 같습니다.\n아무튼, 첫 번째 이스터에그를 표시하는 로직을 다시 확인해봅시다.\nif ( v39 \u0026gt;= 10 ) // 두 번째 이스터에그 else if(v4 == 8) if(!v3(17) || !v3(16)) goto LABEL_50; sub_406910(dword_C29B40, 100, 100); else if (v4 != 65 || !v3(83) || !v3(69) || !v3(32) || !v3(16) || v3(17)) goto LABEL_50; sub_406910(dword_C29B40, 100, 100); 이스터에그가 발동되기 위해서는 v39가 10 미만이어야 하며, v4 == 8이고 !v3(17) || !v3(16)이어야 합니다. 쉽게 설명하자면, O가 10번 미만 눌리고 Control과 Shift가 눌려있는 상태에서 Backspace 키를 눌러야 이스터에그가 발동됩니다.\nv4 == 8가 아닐 때 발동되는 코드도 봅시다. if문 안의 조건이 참일 때 goto LABEL_50;을 해버리므로 조건에 NOT을 씌워야겠죠? v4 == 65 \u0026amp;\u0026amp; v3(83) \u0026amp;\u0026amp; v3(69) \u0026amp;\u0026amp; v3(32) \u0026amp;\u0026amp; v3(16) \u0026amp;\u0026amp; !v3(17) 일 때 이스터에그가 발생됩니다. 다시 말해, S, E, SPACE, SHIFT가 눌렸고 Control이 눌리지 않은 상태에서 A를 누르면 이스터에그가 발생됩니다. 이 로직은 이번에 리버싱을 다시 하면서 알게 됐네요. 전에는 왜 발견하지 못했을까요\u0026hellip;\n두 번째 이스터에그를 표시하는 로직을 봅시다.\nif ( v39 \u0026gt;= 10 ) if ( v4 == 8 ) if ( !v3(17) || !v3(16) ) goto LABEL_50; sub_406910(dword_C278E0, 100, 100); else if ( v4 != 65 || !v3(83) || !v3(69) || !v3(32) || !v3(16) || v3(17) ) goto LABEL_50; sub_406910(dword_C278E0, 100, 100); 나머지는 다 똑같은데 v39가 10 이상이어야 합니다. 즉, O를 10번 이상 눌러야 됩니다.\n결론 이스터에그를 띄우기 위한 키 조합은 다음과 같습니다.\nControl + Shift를 누른 상태에서 Backspace를 12번 이상 누릅니다. I를 한 번 이상 누릅니다. N을 두 번 이상 누릅니다. O를 누릅니다. 10번 미만 누르면 첫 번째 이스터에그가, 10번 이상 누르면 두 번째 이스터에그가 표시됩니다. Ctrl + Shift를 누른 상태에서 Backspace를 누르거나, S + E + Shift + Space를 누르고 Control을 누르지 않은 상태에서 A를 누릅니다. 리버싱을 마치며 re3이라고 GTA3를 리버싱 한 다음 분석한 내용을 토대로 소스코드를 새롭게 작성하여 만들어진 오픈소스(?) GTA3가 있는데요, 한컴타자연습의 바이너리가 단순하다보니 보름정도 시간을 투자하면 오픈소스 한컴타자연습을 만들 수 있을 것 같습니다. 하지만 저작권 문제가 있으니 이스터에그를 찾는것으로 만족하겠습니다.\n이 글에는 이스터에그에 관한 분석 내용만 적었는데요, 사실 세이브파일의 구조나 전반적인 프로그램의 구성도 대충 분석해봤습니다. 제가 WinAPI 개발을 해본 적이 없어서 코드를 평가할 자격이 없는데요, 코드가 꽤나 창의적인(?) 방법으로 작성됐다고 생각합니다. 예를 들자면, 화면에 버튼을 추가할 때 일반적으로 CreateWindow 함수를 사용한다고 알고 있습니다. 그런데 한컴타자연습은 화면에 버튼을 이미지로 그린 다음, 마우스 클릭 이벤트가 발생하면 어느 좌표에서 클릭했는지를 토대로 어떤 버튼이 클릭됐는지 알아내고, 그에 맞는 동작을 하도록 프로그래밍 되어 있습니다. 아무튼 잘 작동하기만 하면 되는거겠죠?\n사실 제가 글 쓰는 것을 잘 못합니다. 머릿속에 하고 싶은 말은 많은데, 그걸 글로 옮기면 이해하기 힘든 괴상한 문장이 나오고 한번 쓰기 시작한 단어나 표현을 계속 반복해서 씁니다. 이 글이 블로그에 올라가는 제대로 된 첫 글일텐데, 사실 쓰다가 도저히 안되겠어서 갖다 버린 글이 두 개나 되고, 이 글도 표현을 다듬느라 일주일정도 붙들었습니다. 잘 이해 안 되는 부분이나 궁금한 점은 댓글을 남겨주시면 감사하겠습니다.\n","permalink":"https://blog.sryu.dev/post/hancom-typing-training-easter-egg/","summary":"고등학교 2학년 때 한컴타자연습 리소스에 이스터에그가 숨겨져 있다는 사실을 우연히 알게 됐는데요, 이스터에그가 더미 데이터로만 존재하는지, 아니면 프로그램 상에서 띄우는 방법이 따로 있는지 궁금해서 한컴타자연습을 리버싱 했었습니다. 프로그램 구조가 많이 단순해 이스터에그를 띄우는 키 조합을 금방 알아낼 수 있었고, 리버싱 결과를 페이스북의 코딩이랑 무관합니다만 그룹에 올려놨습니다.\n블로그를 개설한 지 한 달 정도 됐는데, 뭐라도 올려야 될 것 같아서 키 조합을 어떻게 알아냈는지 리버싱 과정을 정리해서 올려볼려고 합니다. 2년 전에 리버싱 과정을 따로 기록해두지 않아 이번에 리버싱을 다시 했는데, 재작년에 발견하지 못한 또 다른 키 조합도 발견했네요.","title":"한컴타자연습 이스터에그 분석"},{"content":"블로그를 새로 개설했습니다!\n","permalink":"https://blog.sryu.dev/post/hello-world/","summary":"블로그를 새로 개설했습니다!","title":"블로그 개설"},{"content":"","permalink":"https://blog.sryu.dev/categories/","summary":"categories","title":"카테고리"},{"content":"","permalink":"https://blog.sryu.dev/tags/","summary":"tags","title":"태그"}]